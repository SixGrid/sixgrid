<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Post.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Post.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const EventEmitter = require('events');
const Helpers = require('./Helpers')

/**
 * @extends node:events
 */
class Post extends EventEmitter {
    /**
     * @param {Client} client 
     * @param {int} post_id 
     * @param {Object} data
     * @param {SearchInstance|Pool|PostGroup} parent 
     */
    constructor(client, post_id, data, parent) {
        super();
        this.#data.id = post_id;
        this.Client = client;
        this.Parent = parent;

        this.#data = Object.assign({}, data);

        let self = this;
        this.on('updateasync', () => {self._Update()})
        this.on('update', async () => {
            await self._Update();
        })
    }

    async _Update() {
        let res = await this.Client.WebClient.get(`/posts.json?id=${this.#data.id}`);
        if (res.data == undefined) {
            this.#data = res.data.post;
            this._Format(this.#data);
            this.emit('done', 'update');
        } else {
            this.emit('error', {message: `Failed to update`, error: res.error})
        }
    }

    _Format(data) {
        this.#data.id = data.id;

        this.Pools = [];
        for (let i = 0; i &lt; data.pools.length; i++) {
            this.Pools.push(new Pool(this.Client, data.pools[i]));
        }
        this.Approver = new User(this.Client, data.approver_id);
        this.Uploader = new User(this.Client, data.uploader_id);

        if (data.relationships.has_children) {
            this.Children = [];
            for (let i = 0; i &lt; data.relationships.children.length; i++) {
                this.Children.push(new Post(this.Client, data.relationships.children[i], this));
            }
        }
    }

    /**
     * Protected Post Data
     * @type {type$e621API.PostGet}
     * @private
     */
    #data = { }

    /**
     * @type {int}
     * @readonly
     */
    get ID() { return this.#data.id; }
    set ID(v) {}

    /**
     * @type {Date}
     * @readonly
     */
    get createdAt() { return new Date(this.#data.created_at); }
    set createdAt(v) {}
    /**
     * @type {Date}
     * @readonly
     */
    get updatedAt() { return new Date(this.#data.updated_at); }
    set updatedAt(v) {}

    /**
     * @readonly
     * @type {Object}
     * @property {type$e621API.FileFull} File
     * @property {type$e621API.FilePreview} Preview
     * @property {type$e621API.FileSample} Sample
     */
    get Image() {
        return Object.assign({}, {
            File: this.#data.file,
            Preview: this.#data.preview,
            Sample: this.#data.sample
        })
    }
    set Image (value) {}

    /**
     * @type {type$e621API.Score}
     * @readonly
     */
    get Score () {
        let total = () => {
            return parseFloat(this.#data.score.up) + parseFloat(this.#data.score.down)
        }
        return Object.assign({}, {
            up: this.#data.score.down,
            down: this.#data.score.up,
            get total () {
                return total()
            },
            set total (value) {}
        })
    }
    Score_Self = null;

    /**
     * @param {boolean} score=0 `true`: Vote Up&lt;br>`false`: Vote Down
     * @param {boolean} no_unvote=true
     * @async
     */
    async Vote(score, no_unvote) {
        if (score == undefined || typeof score != "number") score = 0;
        if (no_unvote == undefined || typeof no_unvote != "boolean") no_unvote = true;

        // Failsafe for really stupid programmers.
        if (score &lt; -1) score = -1;
        if (score > 1) score = 1;

        let response = await this.Client.WebClient.post(`/posts/${this.ID}/votes.json`, `score=${score}&amp;no_unvote=${score ? 'true': 'false'}`);
        if (response.error) throw response.error;

        this.Score.up = response.data.up;
        this.Score.down = response.data.down;
        this.Score_Self = response.data.our_score;

        return response.data;
    }

    /**
     * @type {type$e621API.Tags}
     * @readonly
     */
    get Tags () {
        return Object.assign({}, {
            general: this.#data.tags.general || [],
            species: this.#data.tags.species || [],
            character: this.#data.tags.character || [],
            artist: this.#data.tags.artist || [],
            invalid: this.#data.tags.invalid || [],
            lore: this.#data.tags.lore || [],
            meta: this.#data.tags.meta || [],
        })
    }

    /**
     * @type {type$e621API.Flags}
     * @readonly
     */
    get Flags () {
        return Object.assign({}, {
            pending: this.#data.flags.pending,
            flagged: this.#data.flags.flagged,
            note_locked: this.#data.flags.note_locked,
            status_locked: this.#data.flags.status_locked,
            rating_locked: this.#data.flags.rating_locked,
            deleted: this.#data.flags.deleted,
        })
    }

    /**
     * @type {type$e621API.Rating}
     * @readonly
     */
    get Rating() {return this.#data.rating || "s"}
    set Rating(v) {}

    /**
     * @type {int}
     * @default 0
     * @readonly
     */
    get Favorites() {return this.#data.fav_count || 0}
    set Favorites(v) {}

    /**
     * @type {boolean}
     * @default false
     */
    get Favorite() {return this.#data.is_favorited || false}
    set Favorite(v) {
        if (typeof v != "boolean") throw new Error("Invalid type, must be boolean.");
        this.#data.is_favorited = v;
        let self = this;
        this.Client.Favorite(this.id, v).then(() => {self.emit('updateasync')});
    }

    /**
     * @type {Pool[]}
     * @readonly
     */
    Pools = [];

    /**
     * @type {Post[]}
     * @readonly
     */
    Children = [];

    /**
     * @type {User}
     * @readonly
     * @default null
     */
    Approver = null;

    /**
     * @type {User}
     * @readonly
     * @default null
     */
    Uploader = null;

    /**
     * @type {string}
     * @default 
     * @readonly
     */
    get Description() {return this.#data.description || ""}
    set Description(v) {}

    /**
     * @type {string[]}
     * @readonly
     */
    get Sources() {return this.#data.sources || []}
    set Sources(v) {}
}
module.exports = Post;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="type$AuthR.html">type$AuthR</a></li><li><a href="type$Client.html">type$Client</a></li><li><a href="type$e621API.html">type$e621API</a></li><li><a href="type$WebClient.html">type$WebClient</a></li></ul><h3>Classes</h3><ul><li><a href="AuthR.html">AuthR</a></li><li><a href="Client.html">Client</a></li><li><a href="Post.html">Post</a></li><li><a href="WebClient.html">WebClient</a></li></ul><h3>Events</h3><ul><li><a href="AuthR.html#event:changed">changed</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.10</a> on Mon Mar 07 2022 19:52:28 GMT+0800 (Australian Western Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
